console.log('I am a simple C4J client');
const net = require('net');
const MessageFramer = require('message-framer');
const JsonRpcProtocol = require('./json-rpc-protocol');
const { spawn } = require('child_process');
//const fetch = require('node-fetch');
const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));
const fs = require('fs').promises;

async function readFileAsBuffer(filePath) {
    const fileContent = await fs.readFile(filePath);
    return fileContent;
}

// upload a local test pattern
async function uploadLocalPattern(imageFile, rpc) {

    const uploadPath = await rpc['testPattern:getUploadPath']({});

    console.log(uploadPath);

    var client = new net.Socket();
    var hostname = '169.254.159.128';
    var port = 80; // http post is on port 80

    return new Promise((resolve, reject) => {
    const result = client.connect(port, hostname, imageFile, uploadPath, async function(err, data) {

        console.log('Connected to: ' + hostname + ':' + port);

        const rpc = new JsonRpcProtocol(client);
    
        // need device name- ip?
        const device = `169.254.159.128`;
        const host = `http://${device}/`;
        const httpPath = host + uploadPath;

        console.log(httpPath);

        const fileContent = await readFileAsBuffer(imageFile);

        const fileBlob = new Blob([fileContent]);
        const formData = new FormData();
        formData.append('file', fileBlob, imageFile);
 
        //let data;
        try {const response = await fetch(httpPath, {
            method: 'POST',
            body: formData
            })
            if (!response.ok) {
                reject(err);
                throw new Error('response not ok');

            }

            else {
            data = await response.json();
            console.log("SrcName:",data.result.token); // SrcName for testPattern:display
            resolve(data);
            //return data; //data.result.token;
            }
        }
        catch(error) {
            console.error('Error:', error);
            throw error;
        }

        // const imageName = response;
        // //console.log(imageName)
        // return imageName;
    });
});

}


// display an uploaded test pattern without saving
async function displayUploadedPattern(imageName, display) {
    try {
        console.log("imName",imageName)
        const result = await display({
            type: "remote",
            srcName: `${imageName}`,
            format: "PNG",
            sync: true
        });
        return result;
    }
    catch(exception) {
        console.error("Error:", exception);
    }
    
}

var client = new net.Socket();
var hostname = '169.254.159.128';
var port = 3003;

client.connect(port, hostname, async function() {
    // Display successful connection message.
    console.log('Connected to: ' + hostname + ':' + port);

    const rpc = new JsonRpcProtocol(client);

    const result = await rpc['testPattern:getIndexList']({});
    //const idx = result.find(item => item."" == 4)
    console.log(result)

    // const show = await rpc['testPattern:show']({
    //     idx: 101, 
    //     sync: false}
    // )

 
    // swap between uploaded black test pattern and the single pixel / cross pattern generated by calibration process, and synchronize with capture
    // need to upload both if unable to control built in patterns.. 

    const display = rpc['testPattern:display'];
    const testimage = "C:\\Acquisition_Data\\Gray_code_patterns4\\pattern_x_0.png";
    //const testimage = "C:\\Users\\MPaulson\\Downloads\\postTestPattern.png";
    const defaultPattern =  "C:\\Acquisition_Data\\crosshairs\\crosshairs.png";



    // name = name of source file, the response from upload POST

    uploadLocalPattern(testimage, rpc)
        .then(data => {
            // if upload is successful..
            console.log('Received data:', data.result.token);
            displayUploadedPattern(data.result.token, display);
        })
        .catch(error => {
            console.error('Error:', error);
            });

    
    return;
    // Default pattern
    uploadLocalPattern(defaultPattern, rpc)
        .then(data => {
            // if upload is successful..
            console.log('Received data:', data.result.token);
        })
        .catch(error => {
            console.error('Error:', error);
            });
    
    // pass SrcName to display
    


});